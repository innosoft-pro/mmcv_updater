import math
import os

import re
import tarfile

import docker

import Config


class DockerImage:
    def __init__(self, container_id=None):
        """
        Initializes the Docker image data.
        NOTE: initialization doesn't mean that the image is valid, only that it is usable!
        :param container_id: (optional) id of a running container to initialize off it.
        """
        # Filesystem-related information. Unused for images that are already loaded
        self.image_file_path = None
        self.image_file_name = None

        # Docker-related variables
        self.docker = docker.from_env()
        self.image = None
        self.container = None

        # Common image variables
        self.version = dict(major=0, minor=0, patch=0)
        self.image_type = "docker"

        # Image size initialization
        # TODO: It would be much better to turn it into a property and update it for running containers,
        #  but df is rather slow, so that could impact performance quite a bit.
        # Not sure if performance is important here, however.
        # Would be better to refactor all the accesses of this variable beforehand.
        self.image_size = math.inf

        if container_id is not None:
            images = self.docker.containers.list(filters=dict(id=container_id))
            # Something went really wrong if there are more than 1 container with the same id
            if len(images) == 1:
                self.container = images[0]
                self.image = self.container.image

                # Semantic versioning
                version = re.search(r"(\d+)\.(\d+)\.(\d+)", self.image.tags[0])
                self.version['major'] = int(version.group(1))
                self.version['minor'] = int(version.group(2))
                self.version['patch'] = int(version.group(3))

                dockerdf = self.docker.df()["Containers"]
                for info in dockerdf:
                    # We might have a partial ID during first run
                    if self.container.id in info["Id"]:
                        self.image_size = info["SizeRootFs"]

    @staticmethod
    def from_file(image_file_path, image_file_name, major, minor, patch):
        """
        Try to load an image from a file.
        The file is a file generated by 'docker save'
        :param image_file_path: Path to the file
        :param image_file_name: Name of the file
        :param major: major version number of the image
        :param minor: minor version number of the image
        :param patch: patch version number of the file
        :return: DockerImage corresponding to the file if loaded successfully, None otherwise
        """
        file_path = image_file_path + "/" + image_file_name

        if os.path.exists(file_path):
            ret = DockerImage()

            ret.image_file_path = image_file_path
            ret.image_file_name = image_file_name

            ret.version["major"] = major
            ret.version["minor"] = minor
            ret.version["patch"] = patch
            # Docker image size is difficult to completely calculate with the tools provided by Docker itself.
            # Instead, the tar's size is taken as an approximation
            # Based on very few samples, this approximation can vary from 20% increase to 80%
            # Write-layer is not calculated either way, so this part can actually help a bit
            ret.image_size = os.stat(file_path).st_size

            return ret
        return None

    def install(self):
        """
        Try to install the image from a file, if possible
        :return: True if installation successful, False otherwise
        """
        if self.image is None and self.container is None:
            try:
                # docker.load requires the binary contents of a tarball with the image data
                with open(f"{self.image_file_path}/{self.image_file_name}", "rb") as image_file:
                    contents = image_file.read()
                    self.image = self.docker.images.load(contents)
                return True
            except FileNotFoundError:
                # TODO: Integrate with the runtime error notification
                pass
            return False
        return True

    def delete(self):
        """
        Tries to stop a container and delete the image associated with it.
        """
        if self.container is not None:
            self.container.stop()
            # Delete the container
            # Actually, this function removes all stopped containers with the old container's id, which does the same
            self.docker.containers.prune(filters={"id": self.container.id})
        # TODO : smarter image retrieval. image[0].tags[0] will probably always work, but still
        self.docker.images.remove(self.image[0].tags[0])

    def run(self):
        """
        Try to run a container for the image. Only 1 container will be started,
         the container will require stopping before starting again
        """
        # Only run 1 copy of the image, I assume?
        # TODO : error retrieval and user notification
        if self.container is None:
            self.container = self.docker.containers.run(self.image[0].tags[0], detach=True)

    def stop(self):
        """
        Stop the container associated with the image
        """
        if self.container is not None:
            self.container.stop()
            self.container = None

    def save_info(self):
        """
        Write the needed information into the configuration file
        """
        Config.write("common", "current_image", "docker")
        Config.write("docker", "current_container", self.container.id)

    @staticmethod
    def get_image(path, filename):
        """
        Try to get an image from a specified file
        :param path: path to the file
        :param filename: name of the file to check
        :return: Docker image if the file is indeed an image, None otherwise
        """
        match = re.search(r"mmcv_(core|incidents|trucks)_(x86|rpi)-(\d+)\.(\d+)\.(\d+)\.tar", filename)
        image = None
        if match is not None:
            # TODO: also check that the update is compatible by architecture.
            # The current problem - there are a lot of possible names that can be acquired via platform.machine()
            # Some of them are x86, some x64, raspberry pi seem to have their own naming
            # Index tables COULD be used, but may be a bit of a hassle to update later.
            # As in, we'll need to update the updater.
            up_major = int(match.group(3))
            up_minor = int(match.group(4))
            up_patch = int(match.group(5))

            # We have a correct name, check the contents next
            try:
                with tarfile.open(path + "/" + filename, "r") as tar:
                    # Quick check - packed docker images have a number of layers with metadata (a folder and 3 files)
                    # Also these 2 files and a description json? (Not sure, the filename is an id-named json)
                    # TODO: for added security, maybe check the presence of layer data - 1 folder, 3 files per layer.
                    tar.getmember("manifest.json")
                    tar.getmember("repositories")
            except KeyError:
                # The tarfile is not a docker image, do nothing
                pass
            except FileNotFoundError:
                # The tarfile doesn't exist
                pass
            else:
                image = DockerImage.from_file(path, filename, up_major, up_minor, up_patch)
        return image

    def get_errors(self):
        """
        Get the error logs associated with the running container
        :return: error logs or other information that needs to be shown
        """
        if self.container is not None:
            # 1. I output both STDOUT and STDERR because some programs may not use STDERR for errors
            #  and STDOUT might help with providing the context for the errors
            logs = self.container.logs(stdout=True, stderr=True)
            if logs is None or len(logs) == 0:
                logs = "No logs yet"
            else:
                logs = logs.replace(b";", b"<br>")
            return logs
        return "No container running!"
